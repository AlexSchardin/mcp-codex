// Vercel API wrapper for MCP server
// Auto-generated by Poke MCP deployment workflow
// Spawns the MCP server as a subprocess and communicates via stdin/stdout

import { spawn } from 'child_process';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { writeFileSync, mkdirSync, rmSync, existsSync } from 'fs';
import { randomUUID } from 'crypto';
import { tmpdir } from 'os';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export default async function handler(req, res) {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    res.status(204).end();
    return;
  }

  res.setHeader('Access-Control-Allow-Origin', '*');

  // Parse the incoming request body for MCP JSON-RPC
  let body = '';
  for await (const chunk of req) {
    body += chunk;
  }

  let jsonBody;
  try {
    jsonBody = JSON.parse(body);
  } catch (e) {
    res.status(400).json({
      jsonrpc: '2.0',
      error: {
        code: -32700,
        message: 'Parse error: ' + e.message
      },
      id: null
    });
    return;
  }

  // Create a unique working directory for this request
  const workDir = join(tmpdir(), 'mcp-' + randomUUID());
  mkdirSync(workDir, { recursive: true });

  // Parse credentials from Authorization header
  const authHeader = req.headers.authorization || '';
  let credentials = {};

  if (authHeader.startsWith('Bearer ')) {
    try {
      credentials = JSON.parse(Buffer.from(authHeader.slice(7), 'base64').toString());
    } catch (e) {
      // Fallback: treat as plain access token
      credentials = { accessToken: authHeader.slice(7) };
    }
  }

  // Write credentials to config file (for file-based credential loading)
  // The spotify-mcp-server expects spotify-config.json
  const configPath = join(workDir, 'spotify-config.json');
  writeFileSync(configPath, JSON.stringify({
    accessToken: credentials.accessToken || '',
    refreshToken: credentials.refreshToken || '',
    // These would be provided by app credentials in production
    clientId: process.env.SPOTIFY_CLIENT_ID || '',
    clientSecret: process.env.SPOTIFY_CLIENT_SECRET || '',
    redirectUri: 'http://localhost:8888/callback'
  }, null, 2));

  // Spawn the MCP server from the build directory
  const serverPath = join(__dirname, '..', 'build', 'index.js');

  return new Promise((resolve) => {
    const cleanup = () => {
      try {
        if (existsSync(workDir)) {
          rmSync(workDir, { recursive: true, force: true });
        }
      } catch {
        // Ignore cleanup errors
      }
    };

    const timeout = setTimeout(() => {
      cleanup();
      res.status(504).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'Server timeout'
        },
        id: jsonBody.id
      });
      resolve();
    }, 25000);

    let responseData = '';
    let stderrData = '';

    const serverProcess = spawn('node', [serverPath], {
      stdio: ['pipe', 'pipe', 'pipe'],
      cwd: workDir,  // Run in the work directory where config file is
      env: { ...process.env }
    });

    serverProcess.stdout.on('data', (data) => {
      responseData += data.toString();
    });

    serverProcess.stderr.on('data', (data) => {
      stderrData += data.toString();
    });

    serverProcess.on('close', (code) => {
      clearTimeout(timeout);
      cleanup();

      // Parse the response - MCP servers output JSON-RPC on stdout
      const lines = responseData.trim().split('\n');
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (!line) continue;
        try {
          const parsed = JSON.parse(line);
          if (typeof parsed === 'object' && parsed !== null && 'jsonrpc' in parsed) {
            res.status(200).json(parsed);
            resolve();
            return;
          }
        } catch {
          // Continue to next line
        }
      }

      // No valid response found
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'No valid response from server' + (stderrData ? ': ' + stderrData.substring(0, 200) : '')
        },
        id: jsonBody.id
      });
      resolve();
    });

    serverProcess.on('error', (err) => {
      clearTimeout(timeout);
      cleanup();
      res.status(500).json({
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: 'Failed to spawn server: ' + err.message
        },
        id: jsonBody.id
      });
      resolve();
    });

    // Send the request to stdin
    serverProcess.stdin.write(JSON.stringify(jsonBody) + '\n');
    serverProcess.stdin.end();
  });
}
